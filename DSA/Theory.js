// Sorting Algorithms (with brief explanation)

// Bubble Sort:
// - Repeatedly compares adjacent elements and swaps if out of order.
// - Time Complexity: O(n²)
// - Easy but inefficient for large arrays.

// Selection Sort:
// - Finds the minimum element and places it at the beginning.
// - Time Complexity: O(n²)
// - Simple, but not very efficient.

// Insertion Sort:
// - Builds the final sorted array one element at a time.
// - Time Complexity: O(n²)
// - Good for small or nearly sorted arrays.

// Merge Sort:
// - Divide and conquer algorithm. Divides the array into halves, sorts them, then merges.
// - Time Complexity: O(n log n)
// - Stable sort and very efficient.

// Quick Sort:
// - Picks a pivot, partitions array into smaller and greater elements, then sorts recursively.
// - Time Complexity: Average: O(n log n), Worst: O(n²)
// - Very fast in practice, but not stable.

// Heap Sort:
// - Uses a heap data structure to sort.
// - Time Complexity: O(n log n)
// - Good for memory constrained environments.

// Counting Sort:
// - Counts occurrences of elements. Only for integers in a known range.
// - Time Complexity: O(n + k)
// - Very fast for small ranges.

// Radix Sort:
// - Sorts numbers digit by digit.
// - Time Complexity: O(nk)
// - Good for integers, stable sort.

// Bucket Sort:
// - Divides elements into buckets and sorts each bucket.
// - Time Complexity: O(n + k)
// - Efficient if input is uniformly distributed.

// ------------------------------------------------------------

// Must-Know Data Structures

// | Type         | Use Cases / Description                          |
// |--------------|--------------------------------------------------|
// | Array        | Index-based storage                              |
// | Linked List  | Dynamic memory, insert/delete efficient          |
// | Stack        | LIFO structure (Back button, undo)               |
// | Queue        | FIFO structure (Print queue, order processing)   |
// | Hash Map     | Key-value pairs (fast lookup)                    |
// | Set          | Unique elements only                             |
// | Tree         | Hierarchical data (like folders, BSTs)           |
// | Graph        | Nodes + edges (social networks, maps)            |
// | Heap         | Priority queues, scheduling                      |
// | Trie         | Efficient word search (autocomplete, dictionary) |
// | Deque        | Double-ended queue                               |

// ------------------------------------------------------------

// DSA Topics You Must Learn (In Suggested Order)

// 1. Arrays  
// 2. Strings  
// 3. Hashing (Map/Set)  
// 4. Sorting Algorithms  
// 5. Two Pointers / Sliding Window  
// 6. Recursion & Backtracking  
// 7. Stack & Queue  
// 8. Linked List  
// 9. Trees (Binary, BST, Traversals)  
// 10. Graphs (BFS, DFS, Dijkstra)  
// 11. Greedy Algorithms  
// 12. Dynamic Programming  
// 13. Tries  
// 14. Heaps & Priority Queues  
// 15. Bit Manipulation
