Sorting Algorithms (with brief explanation)

Bubble Sort:
- Repeatedly compares adjacent elements and swaps if out of order.
- Time Complexity: O(n²)
- Easy but inefficient for large arrays.

Selection Sort:
- Finds the minimum element and places it at the beginning.
- Time Complexity: O(n²)
- Simple, but not very efficient.

Insertion Sort:
- Builds the final sorted array one element at a time.
- Time Complexity: O(n²)
- Good for small or nearly sorted arrays.

Merge Sort:
- Divide and conquer algorithm. Divides the array into halves, sorts them, then merges.
- Time Complexity: O(n log n)
- Stable sort and very efficient.

Quick Sort:
- Picks a pivot, partitions array into smaller and greater elements, then sorts recursively.
- Time Complexity: Average: O(n log n), Worst: O(n²)
- Very fast in practice, but not stable.

Heap Sort:
- Uses a heap data structure to sort.
- Time Complexity: O(n log n)
- Good for memory constrained environments.

Counting Sort:
- Counts occurrences of elements. Only for integers in a known range.
- Time Complexity: O(n + k)
- Very fast for small ranges.

Radix Sort:
- Sorts numbers digit by digit.
- Time Complexity: O(nk)
- Good for integers, stable sort.

Bucket Sort:
- Divides elements into buckets and sorts each bucket.
- Time Complexity: O(n + k)
- Efficient if input is uniformly distributed.

------------------------------------------------------------

Must-Know Data Structures

| Type         | Use Cases / Description                          |
|--------------|--------------------------------------------------|
| Array        | Index-based storage                              |
| Linked List  | Dynamic memory, insert/delete efficient          |
| Stack        | LIFO structure (Back button, undo)               |
| Queue        | FIFO structure (Print queue, order processing)   |
| Hash Map     | Key-value pairs (fast lookup)                    |
| Set          | Unique elements only                             |
| Tree         | Hierarchical data (like folders, BSTs)           |
| Graph        | Nodes + edges (social networks, maps)            |
| Heap         | Priority queues, scheduling                      |
| Trie         | Efficient word search (autocomplete, dictionary) |
| Deque        | Double-ended queue                               |

------------------------------------------------------------

DSA Topics You Must Learn (In Suggested Order)

1. Arrays  
2. Strings  
3. Hashing (Map/Set)  
4. Sorting Algorithms  
5. Two Pointers / Sliding Window  
6. Recursion & Backtracking  
7. Stack & Queue  
8. Linked List  
9. Trees (Binary, BST, Traversals)  
10. Graphs (BFS, DFS, Dijkstra)  
11. Greedy Algorithms  
12. Dynamic Programming  
13. Tries  
14. Heaps & Priority Queues  
15. Bit Manipulation
